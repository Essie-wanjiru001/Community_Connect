const Booking = require('../models/Booking');
const ArtisanProfile = require('../models/ArtisanProfile');
const User = require('../models/User');

exports.getAvailableSlots = async (req, res) => {
  try {
    const { artisanId } = req.params;
    const { date } = req.query;

    const artisan = await ArtisanProfile.findOne({ user: artisanId });
    if (!artisan) {
      return res.status(404).json({ message: 'Artisan not found' });
    }

    const requestedDate = new Date(date);
    const availableSlots = artisan.availability.filter(slot => 
      slot.date.toISOString().split('T')[0] === requestedDate.toISOString().split('T')[0]
    );

    // Filter out already booked slots
    const bookedSlots = await Booking.find({
      artisan: artisanId,
      date: requestedDate,
      status: { $in: ['pending', 'confirmed'] }
    });

    const availableSlotsFiltered = availableSlots.filter(slot => 
      !bookedSlots.some(booking => 
        booking.startTime === slot.startTime && booking.endTime === slot.endTime
      )
    );

    res.json(availableSlotsFiltered);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching available slots', error: error.message });
  }
};

exports.createBooking = async (req, res) => {
  try {
    const { artisanId, date, startTime, endTime, service } = req.body;
    const consumerId = req.user.id;

    const artisan = await ArtisanProfile.findOne({ user: artisanId });
    if (!artisan) {
      return res.status(404).json({ message: 'Artisan not found' });
    }

    // Calculate total price based on service duration and artisan's charges
    const durationHours = (new Date(`2000/01/01 ${endTime}`) - new Date(`2000/01/01 ${startTime}`)) / 3600000;
    const totalPrice = durationHours * parseFloat(artisan.charges);

    const newBooking = new Booking({
      artisan: artisanId,
      consumer: consumerId,
      service,
      date,
      startTime,
      endTime,
      totalPrice,
      status: 'pending'
    });

    await newBooking.save();

    res.status(201).json({ message: 'Booking created successfully', booking: newBooking });
  } catch (error) {
    res.status(500).json({ message: 'Error creating booking', error: error.message });
  }
};

exports.getUserBookings = async (req, res) => {
  try {
    const userId = req.user.id;
    const bookings = await Booking.find({ consumer: userId })
      .populate('artisan', 'name email')
      .sort({ date: 1, startTime: 1 });

    res.json(bookings);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching user bookings', error: error.message });
  }
};

exports.getArtisanBookings = async (req, res) => {
  try {
    const userId = req.user.id;
    const bookings = await Booking.find({ artisan: userId })
      .populate('consumer', 'name email')
      .sort({ date: 1, startTime: 1 });

    res.json(bookings);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching artisan bookings', error: error.message });
  }
};

exports.updateBookingStatus = async (req, res) => {
  try {
    const { bookingId } = req.params;
    const { status } = req.body;

    const booking = await Booking.findByIdAndUpdate(
      bookingId,
      { status },
      { new: true }
    );

    if (!booking) {
      return res.status(404).json({ message: 'Booking not found' });
    }

    res.json({ message: 'Booking status updated successfully', booking });
  } catch (error) {
    res.status(500).json({ message: 'Error updating booking status', error: error.message });
  }
};

module.exports = exports;